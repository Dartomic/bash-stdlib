#!/bin/bash
# bash_functions_stdlib is a set of bash functions for non-specific
# functionality.
#
# Copyright (C) 2015-2016, Andrew Kroshko, all rights reserved.
#
# Author: Andrew Kroshko
# Maintainer: Andrew Kroshko <akroshko.public+devel@gmail.com>
# Created: Fri Mar 27, 2015
# Version: 20160716
# URL: https://github.com/akroshko/bash-stdlib
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.

# WARNING: most of this code has not been rigorously tested or
# verified, use at own risk if working with important data or in
# production settings

test-fail () {
    # this function is just a test to judge a scripts behaviour based
    # on return values
    # TODO: also need a test error
    if [[ false ]]; then
        echo "false"
        return 1
    fi
    echo "not false"
    return 0
}

check-host () {
    # check if current host is a particular host, this will probably
    # become more complex as time goes on
    [[ $(hostname) == "$1" ]]
}

need_new_directory () {
    # create a new directory if it does not already exist
    mkdir -p "$1"
}

verify-operation () {
    # this function verifies a deletion and asks twice to make sure,
    # generally used to ensure an operation is successful before
    # deleting
    local ASKMESSAGE="$1"
    local SUREMESSAGE="$2"
    local RMARG="$3"
    while true; do
        while read -r -t 0;do read -r; done;
        read -n 1 -p "$ASKMESSAGE" YN
        echo ""
        case $YN in
            # TODO: make a bit more general so I can select a command
            [Yy]* ) (home-trash "$RMARG"); break;;
            # are you sure you don't want to delete original
            [Nn]* )
                while read -r -t 0;do read -r; done;
                read -p "$SUREMESSAGE" YNT
                case $YNT in
                    [Yy]* ) return 0;;
                    [Nn]* ) true;;
                    * ) warn "Try again!"
                esac
                ;;
            * ) warn "Please answer yes or no.";;
        esac
    done
}

home-trash () {
    # delete by moving to a trash file that can be periodically
    # checked
    local TRASHFILE="$1"
    mkdir -p ${HOME}/tmp/trash
    \mv --backup=t -- "$TRASHFILE" ${HOME}/tmp/trash
}

date-time-stamp () {
    # return a time-stamp with date in standard format
    echo $(date +%Y%m%d%H%M%S)
}

date-stamp () {
    echo $(date +%Y%m%d)
}

# move this to function ASAP
memory-log () {
    while true; do { cat /proc/meminfo | sed -n 2p ; date ; } | tr "\n" " " ; echo ""; sleep 30; done >> ${HOME}/memory-$(date +%Y%m%d%H%M%S).log
}

ag-show () {
    # show details of a debian package
    apt-cache show "$1"
}
# XXXX: only different when using bash completion
alias ag-show-installed=ag-show

ag-search () {
    # search for a debian package
    apt-cache search "$1"
}

ag-install () {
    # install a debian package
    sudo apt-get install "$1"
}

ag-remove () {
    # uninstall a debian package
    sudo apt-get remove "$1"
}

ag-list () {
    # list files installed by a debian package
    dpkg-query -L "$1"
}

ag-list-installed () {
    if [[ -z "$1" ]]; then
        dpkg-query -l
    else
        dpkg-query -l | grep "$1"
    fi
}

# TODO: see if I can use aes256-gcm@openssh.com for everything

ssh-batch () {
    ssh -o "BatchMode yes" "$@"
}

ssh-batch-lan () {
    ssh -o "Compression no" -c aes256-gcm@openssh.com -o "BatchMode yes" "$@"
}

ssh-batch-interact () {
    # go in in batch mode but allow interaction
    # generally want things to fail when authentication agents not working
    ssh -o "BatchMode yes" -t "$@"
}

ssh-batch-interact-lan () {
    # go in in batch mode but allow interaction
    # generally want things to fail when authentication agents not working
    ssh -o "Compression no" -c aes256-gcm@openssh.com -o "BatchMode yes" -t "$@"
}

ssh-lan () {
    ssh -o "Compression no" "$@"
}

scp-lan () {
    # use scp over a LAN, sets some good options
    scp -o "Compression no" "$@"
}

sftp-lan () {
    # use sftp over a LAN, sets some good options
    sftp -o "Compression no" "$@"
}


sshx () {
    ssh -X -o "Compression yes" "$@"
}

sshnox () {
    # use ssh and explicitly disable X forwarding
    ssh -o "ForwardX11 no" "$@"
}

sshx-lan () {
    ssh -X -o "Compression no" "$@"
}

autossh-tunnel () {
    # set up a tunnel using autossh
    autossh -M 0 -o "BatchMode yes" -o "Compression yes" -N "$@"
}

autossh-tunnel-lan () {
    # set up a tunnel using autossh, compression off best for lan
    autossh -M 0 -o "BatchMode yes" -o "Compression no" -N "$@"
}

transform-resize-web () {
    # resize photos to a nice size for the web
    # TODO: change the prefix name?
    convert "$1" -resize 1200x800 "resize_$1"
}

# transform anything to mp3 using ffmpeg
transform-ffmpeg-mp3 () {
    # convert any media file to an mp3
    # TODO: ffmpeg not on debian currently (8.3)
    ffmpeg -i "$1" -f mp3 "${1%.*}.mp3"
}

transform-rotate-right () {
    # rotate a photo right 90 degrees
    convert "$1" -rotate 90 "rotate_$1"
}

transform-rotate-180 () {
    # flip a photo 180 degrees
    convert "$1" -rotate 180 "rotate_$1"
}

transform-rotate-left () {
    # rotate a photo left 90 degrees
    convert "$1" -rotate 270 "rotate_$1"
}

serve-here () {
    # serve the current directory here on port 8080
    ifconfig
    python -m SimpleHTTPServer 8080
}

nmap-network () {
    # use nmap to show network interfaces
    nmap --iflist
}

nmap-host-ports () {
    if [[ -z "$1" ]]; then
        yell "Requires argument!"
        return 1
    fi
    time nmap -v -sT -p 1-65535 "$1"
}

nmap-host-ports-super () {
    if [[ -z "$1" ]]; then
        yell "Requires argument!"
        return 1
    fi
    time nmap -v -sS -p 1-65535 "$1"
}

nmap-lan () {
    # scan current network, based on common home router addresses,
    # quickly using nmap
    # XXXX: generally takes less than a minute
    time nmap -sP 192.168.0-1.0-255
}

nmap-lan-os () {
    # scan current network, based on common home router addresses,
    # quickly using nmap
    # XXXX: generally takes less than a minute
    time sudo nmap -sS -O 192.168.0-1.0-255
}

nmap-lan-super () {
    # scan current network, based on common home router addresses,
    # slowly using nmap
    # XXXX: generally takes less than a 10 minutes, or lesss than 10 seconds
    time sudo nmap -sS 192.168.0-1.0-255
}

nmap-lan-complete () {
    # scan current network completely using nmap
    time sudo nmap -sP 192.168.0.0/16
}

nmap-lan-complete-super () {
    # scan current network completely and slowly using nmap
    time sudo nmap -sS 192.168.0.0/16
}

netstat-connections () {
    # check current networking connections
    netstat -untap
}

netstat-connections-super () {
    # check current networking connections
    sudo netstat -untap
}

lpr-double-sided-portrait () {
    # print file as double-sided in portrait mode
    lpr -o sides=two-sided-long-edge "$1"
}

lpr-double-sided-landscape () {
    # print file as double-sided in landscape mode
    lpr -o sides=two-sided-short-edge "$1"
}

ls-sort-date () {
    # ls and sort by reverse date
    ls -ltr
}

need_new_symlink () {
    # create new symlink deleting old symlinks but not old files
    # TODO: overwrite and backup files while killing symlinks
    # TODO: do I want to remove and replace symlink even if it is valid?
    # if [[ ! -e "$1" ]]; then
    #     yell "Source $1 does not exist!"
    # fi
    if [[ -e "$2" && ! -h "$2" ]]; then
        # symlink is a file or something
        yell "$2: exists but is not a symlink!!!"
    elif [[ ! -h "$2" ]]; then
        # symlink does not exist at all or is a file
        ln -s "$1" "$2"
    elif [[ -h "$2" && ! -e "$2" ]]; then
        # symlink exists but is invalid
        rm -f "$2"
        ln -s "$1" "$2"
    fi
}

match_string_array () {
    # check if a given string is in a given array
    # string in $1, array in $2
    local e
    for e in "${@:2}"; do [[ "$e" =~ "$1" ]] && return 0; done
    return 1
}

not_match_string_array () {
    # check if a given string is not in a given array
    # string in $1, array in $2
    local e
    for e in "${@:2}"; do [[ "$e" =~ "$1" ]] && return 1; done
    return 0
}

view-def () {
    # view the definition of a bash function
    declare -f "$1"
}

read-file-regexp () {
    # read lines from a file and merge them into a regexp
    local NEWREGEXP=""
    while read line; do
        NEWREGEXP+=$line"|"
    done < "$1"
    echo ${NEWREGEXP::-1}
}

clean-pwd-files-pretend () {
    # see if files in current directory can be renamed to be safe from
    # punctuation and unicode boogeymen
    rename -n "s|'||g" *
    rename -n "s|:||g" *
    rename -n "s|\xe2\x80\x99||g" *
    rename -n "s|\xe2\x80\x93|-|g" *
    rename -n "s|\xe2\x80\x94|-|g" *
    rename -n "s|\xc2\xa1|-|g" *
}

clean-pwd-files () {
    # actually rename files in current directory to be safe from
    # punctuation and unicode boogeymen
    rename "s|'||g" *
    rename "s|:||g" *
    rename "s|\xe2\x80\x99||g" *
    rename "s|\xe2\x80\x93|-|g" *
    rename "s|\xe2\x80\x94|-|g" *
    rename "s|\xc2\xa1|i|g" *
}

psg () {
    if [[ -z "$1" ]]; then
        ps -efj | less
    else
        # TODO: this can be done better!
        ps -efj | head -n 1
        ps -efj | grep "$1"
    fi
}

cpu-throttle-up () {
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "${i}" -g performance
    done
}

cpu-throttle-ondemand () {
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "${i}" -g ondemand
    done
}

cpu-throttle-down () {
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "${i}" -g powersave
    done
}

find-broken-symlinks () {
    # find- for useful find command variations
    find . -type l -xtype l
}

xclip-show-all () {
    h1
    msg "Primary"
    xclip -o -selection p
    h1
    msg "Secondary"
    xclip -o -selection s
    h1
    msg "Clipboard"
    xclip -o -selection c
}

du-sort () {
    # sort by size after using du
    du --summarize --human-readable * 2>/dev/null | sort --human-numeric-sort
}

dd-progress () {
    # TODO: spaces after | ???
    #       try on next big dd
    # ps auxww | grep " dd " |grep -v grep |awk '{print $2}' |while read pid; do kill -USR1 $pid; done
    # http://askubuntu.com/questions/215505/how-do-you-monitor-the-progress-of-dd
    sudo kill -USR1 $(pgrep ^dd)
}

youtube-mp3 () {
    # download mp3 from youtube
    youtube-dl --extract-audio -audio-format mp3 "$1"
}

dconf-grep () {
    # grep the GNOME config database
    dconf dump / | grep -i "$1"
}

dconf-less () {
    # use less to view the GNOME config database
    dconf dump / | less
}

fdi () {
    # search for file matching first argument in tree
    find . -iname "*${1}*"
}

fgi () {
    if [[ -z "${2}" ]]; then
        find . -type f -exec grep -H --color -n "${1}" {}  \;
    else
        find . -type f -iname "*${1}*" -exec grep -H --color -n "${2}" {}  \;
    fi
}

harm-bash () {
    if ps -ef | grep "xbindkeys" | grep -v grep >/dev/null; then
        if [[ -t 0 && -n "$DISPLAY" ]]; then
            killall xbindkeys
        else
            warn "Shell not interactive or no display! Not killing xbindkeys!"
        fi
    fi
    fix-gpg-ssh-permissions
    source ${HOME}/.bash_profile
}

harm-bashrc () {
    fix-gpg-ssh-permissions
    source ${HOME}/.bashrc
}

fix-standard-permissions () {
    true
}

fix-crypt-permissions () {
    # fix the permissions on a cryptography-relevant directory
    if [[ -z "$1" ]]; then
        yell "Must have a file or directory to fix!"
    else
        # fail silently if does not exist
        if [[ -e "$1" ]]; then
            if [[ -d "$1" ]]; then
                chmod --recursive g-rwx "$1"
                chmod --recursive o-rwx "$1"
                chmod u+rwX --recursive "$1"
            else
                chmod g-rwx "$(readlink -f $1)"
                chmod o-rwx "$(readlink -f $1)"
                chmod u+rwX "$(readlink -f $1)"
            fi
        fi
    fi
}

fix-gpg-ssh-permissions () {
    # TODO: start adding things that might be necessary
    # TODO: start adding this to the front of critical operations
    # fix the permissions on the standard gpg and ssh directory
    fix-crypt-permissions "${HOME}"/.gnupg
    fix-crypt-permissions "${HOME}"/.ssh
    fix-crypt-permissions "${HOME}"/.msmtprc
}

backlight-percentage () {
    # XXXX: very device dependent but useful to include, make more general
    echo "`cat /sys/class/backlight/intel_backlight/brightness`*100/`cat /sys/class/backlight/intel_backlight/max_brightness`" | bc -l | xargs printf "%1.0f\n"
}

vcs-check-root () {
    # check if a pull is needed for for child directories if they correspond to common version control systems
    # from https://stackoverflow.com/questions/3258243/git-check-if-pull-needed
    for dirname in ${PWD}/*; do
        [[ -d "$dirname" ]] || continue
        # check for various things
        if [[ -d "$dirname/.git" ]]; then
            # TODO: exclude lines saying [up to date] and just give a summary of branches
            h1 "Checking $dirname/.git"
            pushd . >/dev/null
            cd "$dirname"
            git fetch
            git fetch --verbose
            # h2 "diff origin/master"
            # git diff origin/master --summary
            h2 "pull needed?"
            # TODO: indicate no pull needed
            local STATUS=$(git status -uno)
            if echo "$STATUS" | grep "up-to-date" >/dev/null; then
                msg "Seems up to date!"
            else
                yell "Not up to date!"
            fi
            echo "$STATUS"
            popd >/dev/null
        elif [[ -d "$dirname/.hg" ]]; then
            h1 "Checking $dirname/.hg"
            # TODO: non-functional? I have no remaining hg repos
            # pushd . >/dev/null
            # cd "$dirname"
            # hg fetch --dry-run --verbose
            # popd >/dev/null
        elif [[ -d "$dirname/.svn" ]]; then
            h1 "Checking $dirname/.svn"
            pushd . >/dev/null
            cd "$dirname"
            svn status --show-updates
            popd >/dev/null
        else
            h1 "Not checking $dirname"
        fi
    done
}

vcs-update-versions () {
    # TODO: add fences and safeguards
    # TODO: search recursively with find command
    # find . -not -path "*git*" -type f -exec bash -c 'source ~/.bash_libenv;vcs-update-file-version "{}"'  \;
    for f in ${PWD}/*; do
        [[ -f "$f" ]] || continue
        local FILETYPE=$(file -L "$f")
        # if file starts with #!
        if [[ "$(head -n 1 $f)" =~ ^\#! ]]; then
            # hash comment
            sed -i -e "s/^# Version:.*$/# Version: $(date-stamp)/g" "$f"
            # if not copyright matches this year
            if grep "^# Copyright" $f >/dev/null && ! grep "^# Copyright.*2016" $f >> /dev/null; then
                warn "Need to update year in $f"
            fi
        elif [[ "$FILETYPE" =~ "Lisp/Scheme program" ]] || [[ "$VERSIONFILE" =~ \.el$ ]]; then
            # lisp
            sed -i -e "s/^;; Version:.*$/;; Version: $(date-stamp)/g" "$f"
            # if not copyright matches this year
            if grep "^;; Copyright" $f >/dev/null && ! grep "Copyright.*2016" $f >> /dev/null; then
                warn "Need to update year in $f"
            fi
        elif [[ "$FILETYPE" =~ "LaTeX document" ]]; then
            # latex
            sed -i -e "s/^% Version:.*$/% Version: $(date-stamp)/g" "$f"
            # if not copyright matches this year
            if ! grep "Copyright.*2016" $f >/dev/null; then
                warn "Need to update year in $f"
            fi
        fi
    done
}

fail2ban-check () {
    # check fail2ban status and show number of banned IPs for each date in the past
    sudo zcat /var/log/auth.log*.gz | grep 'Failed password' | grep sshd | awk '{print $1,$2}' | sort -k 1,1M -k 2n | uniq -c
    # a hack to find non-gz logs
    sudo cat /var/log/auth.lo*[^z] | grep 'Failed password' | grep sshd | awk '{print $1,$2}' | sort -k 1,1M -k 2n | uniq -c
    sudo fail2ban-client status ssh
    sudo fail2ban-client status ssh-root
}

drop-caches () {
    su -c "free && sync && echo 3 > /proc/sys/vm/drop_caches && free"
}

mount-disk-uuid () {
    # find mounted disk or ???
    local UUID="$1"
    # allow full UUID path to be given
    if [[ "$UUID" == /dev/disk/by-uuid/* ]]; then
        local UUIDDEVICE="$(readlink -f ${UUID})"
    else
        local UUIDDEVICE="$(readlink -f /dev/disk/by-uuid/${UUID})"
    fi
    if grep -qs "$UUIDDEVICE" /etc/mtab; then
        echo -e $(grep ^"${UUIDDEVICE}[[:space:]]\+" /etc/mtab | cut -d ' ' -f 2)
        return 0
    else
        # TODO: for now I have gnome mount for me but would like to change this
        yell "Disk not mounted!!!"
        return 1
        # # TODO: mount on a temporary directory
        # MOUNTPOINT=$(mktemp -d)
        # sudo mount "${IDDEVICE}" "${MOUNTPOINT}"
        # echo "${MOUNTPOINT}"
    fi
}

device-disk-uuid () {
    # find mounted disk or ???
    local UUID="$1"
    local UUIDDEVICE="$(readlink -f /dev/disk/by-uuid/${UUID})"
    echo ${UUIDDEVICE}
}

vcs-diff-public () {
    # diff the "master" with the "public" branch for current directory or all child directories that are git repositories
    # XXXX: git only for now
    if [[ -d "${PWD}/.git" ]]; then
        git diff public..master
    else
        for dirname in ${PWD}/*; do
            if [[ -d "$dirname/.git" ]]; then
                pushd . >/dev/null
                cd "$dirname"
                if git rev-parse --verify public >/dev/null 2>&1; then
                    h1 "Checking $dirname"
                    git diff master..public --stat
                fi
                popd >/dev/null
            fi
        done
    fi
}

vcs-push-github () {
    # merge public branch and commit to github
    # XXXX: repository must be setup properly
    # TODO: update verions and commit
    # TODO: this probably only works because I use controlmaster
    #       second ssh to git@github.com does not work alone, the pipe makes it freeze
    ssh-batch -T git@github.com >/dev/null 2>&1
    if ! ssh-batch -T git@github.com 2>&1 | grep --color=never "success"; then
        yell "Error connecting to github! Aborting!"
        return 1
    fi
    if ! git checkout public; then
        yell "Checkout unsuccessful!"
        return 1
    fi
    # test the connection before doing any funny business
    git merge --squash -X theirs master
    local COMMITCORRECT=n
    while [[ "$COMMITCORRECT" != "y" ]]; do
        while read -r -t 0;do read -r; done;
        read -p "Enter commit message: " COMMITMESSAGE
        # TODO: add option for quit
        while read -r -t 0;do read -r; done;
        read -n  1 -p "Use commit message (y/n/q)? " COMMITCORRECT
        echo ""
        if [[ "$COMMITCORRECT" == "q" ]]; then
            yell "Aborting!"
            git checkout master
            return 1
        fi
    done
    git commit -a -m "$COMMITMESSAGE"
    # TODO: eventually go "public" locally to "master" globally
    git push --force --set-upstream github public:master
    git checkout master
}

alias dkpg-purge-all='master-dpkg-purge-all'
master-dpkg-purge-all () {
    # purge all files related to uninstalled packages
    if dangerous-function-ask; then
        dpkg -l | grep ^rc | cut -d' ' -f3|xargs sudo dpkg -P
    fi
}

git-serve () {
    # a convienient command to browse code for now
    git instaweb
}

harm-id3-audiobook-all () {
    # set up all audiobooks in immediate subdirectories for my player
    # (after appropriate file renaming)
    if dangerous-function-ask; then
        for d in ${PWD}/*; do
            [[ -d "$d" ]] || continue
            pushd . >/dev/null
            cd "${d}"
            yes | harm-id3-genre-as-audiobook
            yes | harm-id3-album-as-directory
            yes | harm-id3-name-as-filename
            yes | harm-id3-alphabetical-track
            yes | harm-id3-remove-v1
            popd >/dev/null
        done
    fi
}

harm-id3-genre-as-audiobook () {
    # set genre of all .mp3 as audiobook
    if dangerous-function-ask; then
        eyeD3 --to-v2.4 --genre="Audiobook" *.mp3
    fi
}

harm-id3-name-as-filename () {
    # make track name correspond to filename
    if dangerous-function-ask; then
        for F in ${PWD}/*.mp3; do
            local BNAME="${f%%.mp3}"
            # XXXX: basename doesn't work with comma in filename
            local BNAME="${bname##*/}"
            eyeD3 --to-v2.4 --title="$BNAME" "$F"
        done
    fi
}

harm-id3-alphabetical-track () {
    # number tracks based on the alphabetical sort order
    if dangerous-function-ask; then
        # totals cause confusion
        eyeD3 --track-total=0 *.mp3
        local COUNT=1
        for F in ${PWD}/*.mp3; do
            eyeD3 --to-v2.4 --track=$(printf "%03d\n" $COUNT) "$F"
            let COUNT+=1
        done
    fi
}

harm-id3-album-as-directory () {
    # use directory name for album name as all tracks
    if dangerous-function-ask; then
        local ALBUM=$(basename "${PWD}")
        eyeD3 --to-v2.4 --album "$ALBUM" *.mp3
    fi
}

harm-id3-remove-v1 () {
    # remove v1 id3 tags because they interfere with some players
    if dangerous-function-ask; then
        eyeD3 --remove-v1 *.mp3
    fi
}

ls-id3 () {
    # list id3 tags of all mp3s in directory
    eyeD3 *.mp3
}

ag-list-doc () {
    apt-cache search . | grep "\-doc " | cut -d' ' -f1
}

ag-list-packages-only () {
    ag-list-installed | cut -d' ' -f3
}


# the three-fingered claw, see https://stackoverflow.com/questions/1378274/in-a-bash-script-how-can-i-exit-the-entire-script-if-a-certain-condition-occurs
yell () {
    local NEWCOM=$(echo "$0" | sed -r 's|'"${HOME}"'|~|g')
    echo -e "${BRed}$NEWCOM${Red}: $*${Color_Off}" >&2
}

die () {
    yell "$*"; exit 111
}

try () {
    "$@" || die "cannot $*"
}

warn () {
    # XXXX: not good because it starts up a new command, but avoids escaping slashes
    local NEWCOM=$(echo "$0" | sed -r 's|'"${HOME}"'|~|g')
    echo -e "${BYellow}$NEWCOM${Yellow}: $*${Color_Off}" >&2
}

msg () {
    local NEWCOM=$(echo "$0" | sed -r 's|'"${HOME}"'|~|g')
    echo -e "${BGreen}$NEWCOM${Green}: $*${Color_Off}" >&2
}

h1 () {
    if [[ -z "$*" ]]; then
        local OUTSTR=$(echo "================================================================================" | cut -c 1-80)
    else
        local OUTSTR=$(echo "==== $* ================================================================================" | cut -c 1-80)
    fi
    echo -e "${BWhite}${On_Blue}$OUTSTR${Color_Off}" >&2
}

h1-end () {
    if [[ -z "$*" ]]; then
        local OUTSTR=$(echo "" | cut -c 1-80)
    else
        local OUTSTR=$(echo "$*" | cut -c 1-80)
    fi
    echo -e "${BWhite}${On_Blue}<<<<${Color_Off} ${BWhite}$OUTSTR${Color_Off}" >&2
}

h1-script () {
    local OUTSTR=$(echo "==== Running $(basename $0) ================================================================================" | cut -c 1-80)
    echo -e "${BWhite}${On_Blue}$OUTSTR${Color_Off}" >&2
}

h1-script-end () {
    local OUTSTR=$(echo "Finishing $(basename $0)" | cut -c 1-80)
    echo -e "${BWhite}${On_Blue}<<<<${Color_Off} ${BWhite}$OUTSTR${Color_Off}" >&2
}

h2 () {
   if [[ -z "$*" ]]
    then
        local OUTSTR=$(echo "----------------------------------------" | cut -c 1-60)
    else
        local OUTSTR=$(echo "---- $* ----------------------------------------" | cut -c 1-60)
   fi
   # TODO: probably want different color than cyan
   echo -e "${BWhite}${On_Cyan}$OUTSTR${Color_Off}" >&2
}

h3 () {
   if [[ -z "$*" ]]
    then
        local OUTSTR=$(echo "----")
    else
        local OUTSTR=$(echo "---- $*")
    fi
    echo -e "${White}${On_Purple}$OUTSTR${Color_Off}" >&2
}

git-ls () {
    git ls-tree -r master --name-only
}

test-all-colors () {
    # http://askubuntu.com/questions/27314/script-to-display-all-terminal-colors
    for x in 0 1 4 5 7 8; do for i in `seq 30 37`; do for a in `seq 40 47`; do echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "; done; echo; done; done; echo "";
}

aloopback () {
    arecord -vv | sox -t wav - -t wav - highpass 300 | aplay
}

aloopback-high () {
    arecord -vv | sox -t wav - -t wav - highpass 300 | aplay
}

aloopback-low () {
    arecord -vv | sox -t wav - -t wav - lowpass 300 | aplay
}

vcs-init-full () {
    # TODO: check for files existing
    git init && git add * && git commit -a -m 'initial commit'
}

check-emacs-daemon () {
    ps -ef | grep "emacs --daemon" | grep -v grep >/dev/null
    return $?
}

check-chromium () {
    ps -ef | grep "/usr/lib/chromium/chromium" | grep -v grep >/dev/null
    return $?
}

check-firefox () {
    ps -ef | grep "firefox\|iceweasel" | grep -v grep >/dev/null
    return $?
}

disk-info () {
    if [[ -b "$1" ]]; then
        h1
        msg "$1"
        sudo smartctl -A "$1"
    fi
}

monitor-disks () {
    disk-info /dev/sda
    disk-info /dev/sdb
    disk-info /dev/sdc
    disk-info /dev/sdd
    disk-info /dev/sde
    disk-info /dev/sdf
}


disk-temp () {
    if [[ -b "$1" ]]; then
        h1
        msg "$1"
        sudo hddtemp "$1"
        sudo smartctl -A "$1" | grep -i temperature
    fi
}

monitor-disk-temp () {
    disk-temp /dev/sda
    disk-temp /dev/sdb
    disk-temp /dev/sdc
    disk-temp /dev/sdd
    disk-temp /dev/sde
    disk-temp /dev/sdf
}

monitor-disk-speed () {
    # https://www.webhostingtalk.com/showthread.php?t=906573
    # http://www.yasith.info/2010/01/how-to-check-hard-disk-performance-and.html
    sudo hdparm -tT /dev/"$1"
}

fix-permissive-permissions () {
    if [[ -e "$1" ]]; then
        chmod 755 "$1"
    fi
}

fix-permissive-permissions-recursive () {
    if [[ -d "$1" ]]; then
        chmod -R 755 "$1"
    fi
}

add-line-if-not-exist () {
    local THEFILE="$1"
    local NEWLINE="$2"
    grep -q -F "$NEWLINE" "$THEFILE" || echo "$NEWLINE" >> "$THEFILE"
}

kill-blank-lines () {
    sed -n -e '/^\s*$/d' "$1"
}

screen-select () {
    # TODO: do I want letters instead???
    local SCREENSESSIONS=$(screen -ls | grep pts | cut -f1 -d"." | sed -e 's/^[[:space:]]*//g')
    if [[ -n "$SCREENSESSIONS" ]]; then
        #Set the field separator to new line
        IFS=$'\n'
        #Try to iterate over each line
        local count=1
        for item in $SCREENSESSIONS; do
            echo "$count) $item"
            local count=$(( $count + 1 ))
        done
        while read -r -t 0;do read -r; done;
        read -n 1 -p "Enter the screen session: " SCREENSELECT
        echo ""
        screen -dr $(sed -n "${SCREENSELECT}"p <<< "${SCREENSESSIONS}")
    else
        false
    fi
}

sage-notebook () {
    # open a Sage notebook and browser securely on port 18080
    # XXXX: requires defining of ${PYTHON_NOTEBOOK_ROOT} before calling
    if [[ -n "${PYTHON_NOTEBOOK_ROOT}" ]]; then
       bleachbit --overwrite --clean epiphany.* google_chrome.*
       local NBPATH="${PYTHON_NOTEBOOK_ROOT}/sage-notebooks-${HOSTNAME}.sagenb"
       mkdir -p "${NBPATH}"
       # XXXX: grep to avoid just sage-notebook from scripts that might run this
       if ps -ef | grep "src/bin/sage-notebook" | grep -v grep >/dev/null; then
           sage-notebook-browser
       else
           # TODO: select firefox and chromium?
           SAGE_BROWSER="nohup firefox" sage --notebook=sagenb secure=True port=18080 automatic_login=True interface='' directory="${NBPATH}"
       fi
    else
        yell '${PYTHON_NOTEBOOK_ROOT} not defined!!!'
    fi
}

# TODO: support multiple browsers?
sage-notebook-browser () {
    # open just the browser for a running Sage notebook
    if false; then
        bleachbit --overwrite --clean google_chrome.*
        chromium https://localhost:18080/
    else
        # TODO: shred firefox if not running
        firefox https://localhost:18080/
    fi
}

sage-jupyter-notebook () {
    # open an iPython notebook and browser using the Sage platorm on port 18888
    # TODO: need to control where goes
    # XXXX: requires defining of ${PYTHON_NOTEBOOK_ROOT} before calling
    if [[ -n "${JUPYTER_NOTEBOOK_ROOT}" ]]; then
        bleachbit --overwrite --clean epiphany.* google_chrome.*
        # set a good directory for these
        local NBPATH="${JUPYTER_NOTEBOOK_ROOT}/sage-jupyter-projects"
        mkdir -p "${NBPATH}"
        # TODO: subsitute for --deep-reload --automagic --secure --pprint depricated options
        if ps -ef | grep -- "--notebook=jupyter" | grep -v grep >/dev/null; then
            sage-jupyter-notebook-browser
        else
            sage --notebook=jupyter --notebook-dir="${NBPATH}" --browser="firefox" --port=18888
        fi
    else
        yell '${PYTHON_NOTEBOOK_ROOT} not defined!!!'
    fi
}

# TODO: support multiple browsers?
sage-jupyter-notebook-browser () {
    # open just the browser for a running iPython notebook
    bleachbit --overwrite --clean epiphany.* google_chrome.*
    firefox http://localhost:18888/
}

file-mimetype () {
    # quick way to get mimetype
    file --mime-type "$1"
}

ssh-scs () {
    # XXXX: this one autodetaches after exit from screen session
    ssh "$@" -t "bash --rcfile ~/.bash_libenv -li -c \"screen-select\""
    # XXXX: this one stays attached after exit from screen session
    # ssh "$@" -t "bash --rcfile ~/.bash_libenv -li -c \"screen-select;/bin/bash\""
}

youtube-pause () {
    # global function to pause a running Youtube in Conkeror
    # get current window
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    local CURRENTYOUTUBE=
    xdotool search --onlyvisible --name youtube | while IFS= read -r line; do
        if xdotool search --class conkeror | grep "${line}" >/dev/null; then
            xdotool windowminimize "${line}"
        fi
    done
    # turn off youtube
    # TODO: limit to conkeror
    xdotool search --name youtube | while IFS= read -r line; do
        if xdotool search --class conkeror | grep "${line}" >/dev/null; then
            xdotool windowfocus --sync "${line}";
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.05
            conkeror -f youtube-pause
            if [[ "${line}" == "${CURRENTWINDOW}" ]]; then
                local CURRENTYOUTUBE=1
            fi
        fi
    done
    # restore focus if not youtube window
    if [[ -n "$CURRENTYOUTUBE" ]]; then
        xdotool windowactivate --sync ${CURRENTWINDOW}
    fi
}

youtube-restore () {
    # global function to restore a running Youtube in Conkeror
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --onlyvisible --name youtube | while IFS= read -r line; do
        if xdotool search --class conkeror | grep "${line}" >/dev/null; then
            xdotool windowfocus --sync "${line}"
            xdotool windowactivate --sync "${line}"
        fi
    done
    xdotool search --name youtube | while IFS= read -r line; do
       if xdotool search --class conkeror | grep "${line}" >/dev/null; then
           xdotool windowfocus --sync "${line}";
           xdotool windowactivate --sync "${line}"
           # TODO: very arbitrary delay, perhaps wait for something to return
           sleep 0.05
           conkeror -f youtube-play
        fi
    done
    # restore focus
    xdotool windowactivate --sync ${CURRENTWINDOW}
}

youtube-previous () {
    # global function to see previous video in youtube playlist
    # TODO: if no window here
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --name youtube | while IFS= read -r line; do
        if xdotool search --class conkeror | grep "${line}" >/dev/null; then
            xdotool windowfocus --sync "${line}";
            xdotool windowactivate --sync "${line}"
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.1
            conkeror -f youtube-previous
        fi
    done
    # TODO: very arbitrary, perhaps wait for something to return
    sleep 0.5
    xdotool windowactivate --sync ${CURRENTWINDOW}
}

youtube-next () {
    # global function to see previous video in youtube playlist
    # TODO: if no window here
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --name youtube | while IFS= read -r line; do
        if xdotool search --class conkeror | grep "${line}" >/dev/null; then
            xdotool windowfocus --sync "${line}"
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.1
            conkeror -f youtube-next
        fi
    done
    # TODO: very arbitrary delay, perhaps wait for something to return
    sleep 0.5
    xdotool windowactivate --sync ${CURRENTWINDOW}
}

master-boss-key () {
    # get current window
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    # kill volume
    amixer set Master mute
    # https://askubuntu.com/questions/26068/how-do-you-mute-from-the-command-line
    # amixer -c 0 set Master playback 0% mute
    # minimize browser windows, do they ever not have their name in title?
    # TODO: remove from taskbar
    # TODO: try out with windowclass too
    xdotool search --onlyvisible --name conkeror | while IFS= read -r line; do
        xdotool windowminimize "${line}"
    done
    xdotool search --onlyvisible --name firefox | while IFS= read -r line; do
        xdotool windowminimize "${line}"
    done
    # xdotool search --onlyvisible --name iceweasel | while IFS= read -r line; do
    #     xdotool windowminimize "${line}"
    # done
    # turn off youtube
    # TODO: limit to conkeror
    xdotool search --name youtube | while IFS= read -r line; do
        if xdotool search --class conkeror | grep "${line}" >/dev/null; then
            xdotool windowfocus --sync "${line}";
            sleep 0.05
            conkeror -f youtube-pause
        fi
    done
    # restore focus
    xdotool windowactivate --sync ${CURRENTWINDOW}
}

master-unboss-key () {
    # kill volume
    amixer set Master unmute
    # unminimize all windows
    # TODO: use xdotool to restore instead?
    # TODO: at least add back to taskbar
    # wmctrl -r conkeror  -b remove,shaded,skip_taskbar
    # wmctrl -r firefox   -b remove,shaded,skip_taskbar
    # wmctrl -r remove   -b remove,shaded,skip_taskbar
}

focus-emacs-window () {
    # TODO: do something a little nicer, maybe use xdotool
    wmctrl -x -a emacs.Emacs
}

################################################################################
## enumerate things like block devices

enumerate-physical-disks () {
    # find all physical disks
    # TODO: will likely need to be improved for all appropriate uses
    for d in /dev/sd*; do
        [[ -b "$d" && ! "$d" =~ .*[[:digit:]] ]] || continue
        echo "$d"
    done
}

enumerate-crypt-disks () {
    # find all decrypted block devices
    # TODO: will likely need to be improved for all appropriate uses
    for d in /dev/mapper/crypt--*; do
        [[ -b "$d" ]] || continue
        echo "$d"
    done
}

df-crypt-disks () {
    # get information on decrypted block devices
    df -h $(enumerate-crypt-disks)
}

smartctl-disks () {
    # check overall health of all disks
    for d in $(enumerate-physical-disks); do
        local SMARTOUTPUT=$(sudo smartctl -H "$d")
        if [[ $(($? & 1)) ]]; then
            echo -n "$d: "
            # XXXX: to use this in scripts I have to add smartctl to no password sudo files
            echo "$SMARTOUTPUT" | grep --color=never "overall-health"
        fi
    done
}

select-disk-uuid-usb () {
    # select a usb disk by UUID or alternately any other mounted drive
    # XXXX: doesn't work with more than 9 drives, but could be fixed
    # TODO: are usb always UUID
    # create array
    local USBARRAY=()
    if [[ -n "$1" ]]; then
        if [[ -e /dev/disk/by-uuid/"$1" ]]; then
            if grep -qs $(readlink -f /dev/disk/by-uuid/"$1") /proc/mounts; then
                echo "0) $1 (default, mounted)" >&2
            else
                echo "0) $1 (default, not mounted)" >&2
            fi
        else
            echo "0) $1 (default, not found)" >&2
        fi
    fi
    local count=1
    for d in /dev/disk/by-uuid/*; do
        [[ "$d" == "/dev/disk/by-uuid/$1" ]] && continue
        if /sbin/udevadm info --query=all --name=$(readlink -f $d) | grep ID_BUS >/dev/null; then
            printf "$count) %-55s  %s\n" "$d" "$(df -H $d | grep -v ^Filesystem)"
            local count=$(( $count + 1 ))
            USBARRAY+=("$d")
        fi
    done
    echo "$count) Non-USB drive" >&2
    echo "-) Cancel" >&2
    while read -r -t 0;do read -r; done;
    read -n 1 -p "Enter the USB drive: " USBSELECT >&2
    echo "" >&2
    if [[ $USBSELECT == "-" ]]; then
        echo "Canceled!" >&2
        return 1
    fi
    # TODO: remove home and root mount once I test more, these will almost never be the right answer
    local count=1
    if [[ $USBSELECT == "0" && -n "$1" ]]; then
        echo "/dev/disk/by-uuid/$1"
        return 0
    elif [[ $USBSELECT == "$count" ]]; then
        echo "Non-USB alternate!" >&2
        IFS=$(echo -en "\n\b")
        local ALTERNATEARRAY=()
        local count=1

        for a in $(df | grep -v "udev\|tmpfs\|^Filesystem"); do
            echo "$count) $a" >&2
            ALTERNATEARRAY+=("$a")
            local count=$(( $count + 1 ))
        done
        while read -r -t 0;do read -r; done;
        read -n 1 -p "Enter an alternate drive: " ALTERNATESELECT >&2
        echo "" >&2
        if [[ $ALTERNATESELECT == "0" ]] || ! [[ $ALTERNATESELECT =~ ^[0-9]+$ ]] || (( $ALTERNATESELECT >= $count )); then
            return 1
        fi
        local ALTERNATESELECT=$(( $ALTERNATESELECT - 1 ))
        # XXXX: get first column because we use df for this
        echo ${ALTERNATEARRAY[$ALTERNATESELECT]} | cut -d' ' -f1
        return 0
    fi
    if ! [[ $USBSELECT =~ ^[0-9]$ ]] || (( $USBSELECT >= $count )); then
        return 1
    fi
    local USBSELECT=$(( $USBSELECT - 1 ))
    # TODO: keep ensuring only proper thing is every returned
    echo ${USBARRAY[$USBSELECT]}
    return 0
}

dangerous-function-ask () {
    while read -r -t 0;do read -r; done;
    read -n 1 -p "Dangerous function! Continue (y/n)? " YN
    echo ""
    if [[ "$YN" == "y" ]]; then
        true
    else
        false
    fi
}

continue-ask () {
    while read -r -t 0;do read -r; done;
    read -n 1 -p "Continue (y/n)? " YN
    echo ""
    if [[ "$YN" == "y" ]]; then
        true
    else
        false
    fi
}

vcs-grep-conflicted () {
    # find git conflicted markers in current directory tree
    # TODO: proper return values?
    # TODO: avoid running /home or above... takes way too long!
    find . -not -path "*.git*" -type f -exec grep -nH --color "^<<<<<<< \|^>>>>>>> \|^=======$\|^####### " {} \;
}

flashplayer-update () {
    sudo update-flashplugin-nonfree --install --verbose
}

mdstat-status () {
    local MDSTAT="$(cat /proc/mdstat | sed -n '/^md\|^[[:space:]]*\[\|blocks/p')"
    local FIRST=1
    IFS=$'\n'
    for i in $(echo "${MDSTAT}"); do
        if [[ "$i" =~ ^m.* ]]; then
            printf "$i"
        else
            local SELECTED=$(echo "$i" | grep --color=never -Eo "\[[A-Za-z]*\]$")
            if [[ -n "$SELECTED" ]]; then
                echo " $SELECTED"
            fi
        fi
    done
}

repl-restartable () {
    # restart a repl over and over again if desired
    local TRYAGAIN=" "
    while [[ "${TRYAGAIN}" == " " ]]; do
        ($@)
        while read -r -t 0;do read -r; done;
        IFS= read -n 1 -p 'Press [Enter] to exit or [Space] to restart...' TRYAGAIN
        if [[ "${TRYAGAIN}" == " " ]]; then
            reset
        fi
    done
}

vcs-attr () {
    # https://stackoverflow.com/questions/6855712/why-does-git-treat-this-text-file-as-a-binary-file
    # check attributes
    git check-attr --all -- "$1"
}

################################################################################
## genric download for Canada NTS topo maps
## good scripts for slurping data from other ftp websites

wget-download-canmatrix2-doc () {
    local NEWDIR="${HOME}/mnt-secondary/"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --restrict-file-names=unix \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=300 \
      --waitretry=60 \
      ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/doc/
    popd >/dev/null
}

wget-download-canmatrix2-50k-preview () {
    local NEWDIR="${HOME}/mnt-secondary"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    popd >/dev/null
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --restrict-file-names=unix \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=600 \
      --waitretry=60 \
      ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/50k/
}

wget-download-canmatrix2-250k-preview () {
    local NEWDIR="${HOME}/mnt-secondary"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    popd >/dev/null
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --restrict-file-names=unix \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=600 \
      --waitretry=60 \
      ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/250k/
}

wget-download-canmatrix2 () {
    local NEWDIR="${HOME}/mnt-secondary"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    # TODO: need an alias for this type of download
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=600 \
      --waitretry=60 \
      "$1"
    popd >/dev/null
}

wget-current-canmatrix () {
    # expect to take about 16*((16 * 12) + 60) per large grid = 4032min per large numbered grid
    # generally run this on my server to an external hard drive at ~/mnt
    local URLS=("ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/50k_tif/104/p")
    if ! type send-returncode-mail >/dev/null; then
        warn "No text message progress reports, send-returncode-mail function not configured."
        alias send-returncode-mail="false"
    else
        true
        send-returncode-mail "Canmatrix- starting!"
    fi
    if grep -qs ${HOME}/mnt-secondary /proc/self/mounts >/dev/null; then
        {
            time {
                mkdir -p "${HOME}"/mnt-secondary
                pushd . >/dev/null
                cd "${HOME}"/mnt-secondary
                # 83 urls, area around edmonton
                h1 "Starting!!!"
                for URL in "${URLS[@]}"; do
                    h2 "Next!!!"
                    h3 "$URL"
                    wget-download-canmatrix2 "$URL"
                    # TODO: fix this, probably by aliasing send-returncode-mail to false if not exist
                    send-returncode-mail "Canmatrix- done another grid!" "$URL"
                    sleep $(( $RANDOM % 60 + 30 ))m
                    # test code
                    # echo "$URL"
                    # sleep $(( $RANDOM % 60 + 30 ))s
                done
                popd >/dev/null
            }
        } 2>&1 | tee -a "${HOME}"/mnt-secondary/canmatrix2-$(date-time-stamp).log
        send-returncode-mail "Canmatrix- done grid script!"
    else
        yell "Nothing mounted to collect data!!!"
    fi
}

add-timestamp-head-of-all-files () {
    for f in ${PWD}/*; do
        [[ -f "$f" ]] || continue
        [[ ! "$(basename $f)" =~ [0-9]{14}--.* ]] || continue
        echo "Moving $(basename $f)"
        mv "$(basename $f)" "$(stat $(basename $f) | grep Modify: | sed -e 's/Modify: //' | sed -e 's/-//g' | sed -e 's/://g' | sed -e 's/\..*//g' | sed -e 's/ //g')--$(basename $f)"
    done
}

wget-check-log () {
    # do a quick check of a log file to make sure everything is saved properly
    cat "$1" | grep saved | grep -v listing
}

read-mail () {
    less /var/spool/mail/${USERNAME}
}

gpg-decrypt () {
    gpg2-batch --decrypt "$1" 2>/dev/null
}

svg2png-hq () {
    if [[ -z "$1" ]]; then
        yell "No input!"
        return 1
    fi
    local OUTPUT="${1%%.svg}.png"
    if [[ -f "$OUTPUT" ]]; then
        yell "Output $OUTPUT already exists!!!"
        return 1
    else
        convert -density 300 -resize 2000x "$1" "$OUTPUT"
    fi
}

function ls-cron () {
    crontab -u ${USERNAME} -l
}

function ag-rdep () {
    apt-cache rdepends "$1"
}

function ls-mime-files () {
    # list mime settings
    # https://wiki.archlinux.org/index.php/default_applications
    local THEFILES=("$HOME/.config/$desktop-mimeapps.list" "$HOME/.config/mimeapps.list" "/etc/xdg/mimeapps.list" "$HOME/.local/share/applications/mimeapps.list" "/usr/local/share/applications/mimeapps.list" "/usr/share/applications/mimeapps.list")
    for f in ${THEFILES[@]}; do
        if [[ -e "$f" ]]; then
            h3 "$f"
            cat "$f"
        else
            warn "$f not exist!"
        fi
    done

}

function ls-mime-files2 () {
    # see https://unix.stackexchange.com/questions/36380/how-to-properly-and-easy-configure-xdg-open-without-any-enviroment
    # XXXX: changed variable from dd, bad name for bash variable
    for thedir in /usr/share/applications "${HOME}"/.local/share/applications; do
        h2 "$thedir"
        for thefile in $(ls $thedir 2>/dev/null | grep "\\.desktop$"); do
            h3 "$thefile"
            for m in $(grep MimeType $thedir/$thefile | cut -d= -f2 | tr ";" " "); do
                echo xdg-mime default $thefile $m;
            done;
        done;
    done
}

fetch-compile-sage-nice () {
    /usr/bin/nice -n 19 /usr/bin/ionice -c3 fetch-compile-sage
}

fetch-compile-sage () {
    # fetch and compile current version of sage
    # usage: use --finalize to finalize the setup
    # XXXX: need to set sage variables elsewhere
    # TODO: check for valid installation
    if [[ -z "$SAGEVERSION" || -z "$SAGEVERSIONMD5" ]]; then
        msg "Using default sage versions."
        # update for every new sage
        local SAGEVERSION="7.3"
        local SAGEVERSIONMD5="a289e955f9c94be3e4420ee86d8302a7"
        local SAGEMIRROR="http://www.cecm.sfu.ca/sage/src/"
        # TODO: put this somewhere else
        local SAGELOCATION=/home/akroshko/cic-small/distfiles-current
    fi
    if [[ -d /opt/sage-"$SAGEVERSION" && "$1" != "--finalize" ]]; then
        if /opt/sage-"$SAGEVERSION"/sage --version; then
            warn "/opt/sage-$SAGEVERSION already present and appears functional."
        else
            yell "/opt/sage-$SAGEVERSION present but appears non-functional."
        fi
        return 1
    fi
    sudo true
    if [[ "$1" != "--finalize" ]]; then
        sudo apt-get update
        sudo apt-get install gnutls-bin gnutls-doc libssl1.0.0 libssl-dev libssl-doc
        sudo apt-get install texlive dvipng ImageMagick
        if [[ -e "${SAGELOCATION}"/sage-"$SAGEVERSION".tar.gz ]]; then
            pushd . >/dev/null
            cd "${SAGELOCATION}"
            msg "Already found in distfiles location!"
        else
            # TODO: put into ~/tmp for more universal use
            # TODO: proper error message if md5sum is not good
            if [[ ! -e "${HOME}"/tmp/sage-download/sage-"${SAGEVERSION}".tar.gz || ! $(md5sum "${HOME}"/tmp/sage-download/sage-"${SAGEVERSION}".tar.gz | cut -d' ' -f1) == "${SAGEVERSIONMD5}" ]]; then
                msg "Downloading sagemath!"
                if [[ -e "${HOME}"/tmp/sage-download ]]
                then
                    rm -rf "${HOME}"/tmp/sage-download
                fi
                mkdir -p "${HOME}"/tmp/sage-download
                pushd . >/dev/null
                cd "${HOME}"/tmp/sage-download
                # should I delete this?
                # TODO: does the tarball already exist?
                #       do not delete directory in this case
                wget "$SAGEMIRROR"/sage-"${SAGEVERSION}".tar.gz .
                msg "Finished downloading!"
            else
                msg "Sagemath already downloaded!"
                pushd . >/dev/null
                cd "${HOME}"/tmp/sage-download
            fi
        fi
        MD5SUMCURRENT=$(md5sum sage-"$SAGEVERSION".tar.gz | cut -d' ' -f1)
        echo "\"$MD5SUMCURRENT\" should be \"$SAGEVERSIONMD5\""
        if [[ "$MD5SUMCURRENT" != "$SAGEVERSIONMD5" ]]; then
            yell "md5 sum incorrect!"
            return 1
        fi
        msg "md5 sum correct!"
        msg "Unpacking!"
        if [[ -d sage-"${SAGEVERSION}" ]]; then
            rm -rf sage-"${SAGEVERSION}"
        fi
        tar xvzf sage-"${SAGEVERSION}".tar.gz
        # check installation
        msg "Must now move installation directory to /opt"
        while read -r -t 0;do read -r; done;
        read -n 1 -p "Continue with build (y/n)? " yn
        echo ""
        if [[ "$yn" == "y" ]]; then
            sudo mv ./sage-"${SAGEVERSION}" /opt
            cd /opt/sage-"${SAGEVERSION}"
        else
            return 1
        fi
        # make sure I don't overload my crappy vunerable portable computers
        if [[ "$HOSTNAME" =~ laptop || "$HOSTNAME" =~ netbook ]]; then
            MAKE='make -j1' time make
        else
            MAKE='make -j8' time make
        fi
        # TODO: option to just finalize
        while read -r -t 0;do read -r; done;
        read -n 1 -p "Build OK and finalize setup? (y/n)? " yn2
        echo ""
    else
        local yn2="y"
        pushd . >/dev/null
        cd /opt/sage-"${SAGEVERSION}"
    fi
    # TODO: make sure I can rerun this if necesssary
    # TODO: make an upgrade
    if [[ "$yn2" == "y" ]]; then
        msg "Exit sage when done!"
        ./sage
        ./sage -i openssl
        ./sage -pip install --upgrade pip
        ./sage -pip install pyopenssl
        ./sage -pip install psycopg2
        ./sage -pip install dill
        ./sage -pip install multiprocess
        # install sage mode
        ./sage -f sage_mode
        # make docs
        make doc
        # TODO: overwrite binary, but ask first
        if [[ -e /usr/local/bin/sage ]]; then
            sudo rm /usr/local/bin/sage
        fi
        sudo ln -s /opt/sage-"${SAGEVERSION}"/sage /usr/local/bin
    else
        echo "Not finalizing!  Can be done later with --finalize"
    fi
    # try running sage
    msg "Exit sage when done!"
    ./sage
    msg "Installation done!"
    popd >/dev/null
}

caps-toggle () {
    # toggle caps just in case
    xdotool key Caps_Lock
}

view-mail () {
    tail -n 200 /var/spool/mail/${USERNAME}
}

srvg () {
    if [[ -z "$1" ]]; then
        service --status-all
    else
        service --status-all | grep "$1"
    fi
}

srvr () {
    sudo service "$1" restart
}

srvs () {
    sudo service "$1" status
}

flatten-current-directory () {
    if [[ "$1" != "--for-real" ]]; then
        find . -mindepth 2 -type f -exec mv {} .
    else
        yell "Dangerous function!!! Use --for-real!!!"
    fi
}

dunst-notifications () {
    printf "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
    grep "summary: \|body: " "${HOME}"/tmp/dunst-current.log | grep -v \'\' | sed -e 's/^[ \t]*//' | sed -e 's/body: /    /' | sed -e 's/summary: //'
}

vcs-incoming () {
    git log ..origin/master
}

build-install-software () {
    # assumes I'm in directory with appropriate subdirectories
    # TODO: compile against downloaded poppler
    sudo true
    h2 "pip"
    curl https://bootstrap.pypa.io/get-pip.py | sudo python
    h2 "xpdf"
    pushd . >/dev/null
    cd xpdf-3.04
    # these work on debian 8.x
    make clean
    ./configure --with-freetype2-library=/usr/lib/x86_64-linux-gnu \
                --with-freetype2-includes=/usr/include/freetype2 \
                --with-Xm-library=/usr/lib \
                --with-Xm-includes=/usr/include/Xm
    make
    sudo make install
    popd >/dev/null
    h2 "feh"
    pushd . >/dev/null
    cd feh
    make clean
    make exif=1 help=1 xinerama=0
    sudo make install
    popd >/dev/null
    h2 "mupdf"
    pushd . >/dev/null
    cd mupdf
    make clean
    # draconian
    git fetch --all
    git reset --hard origin/master
    git pull
    git submodule update --init --force
    make
    sudo make install
    popd >/dev/null
    h2 "girara"
    pushd . >/dev/null
    cd girara
    make clean
    make
    sudo make install
    popd >/dev/null
    h2 "zathura"
    pushd . >/dev/null
    cd zathura
    make clean
    make
    sudo make install
    popd >/dev/null
}

ag-list-explicitly-installed () {
    aptitude search '~i !~M'
}

amixer-volumes () {
    echo $(amixer get Master | grep Front.*Playback | tr "\\n" " " | sed -e 's/Front//g' -e 's/Playback//g' -e 's/\s[0-9]\+//g' -e 's/  */ /g')
}

notify-amixer-volumes () {
    notify-send "$(amixer-volumes)" -t 200
}

show-all-x-displays () {
    # https://unix.stackexchange.com/questions/17255/is-there-a-command-to-list-all-open-displays-on-a-machine
    cd /tmp/.X11-unix && for x in X*; do echo ":${x#X}"; done
}

phoronix-describe-all-tests () {
    (IFS=$'\n'
     for testline in $(\phoronix-test-suite list-available-tests | tail -n +5 | head -n -2); do
         h2 $(echo "$testline" | awk '{ print $1 }')
         \phoronix-test-suite info $(echo "$testline" | awk '{ print $1 }')
     done)
}

inhibit-powersave () {
    # make sure screensaver does not restart
    # TODO: inhibit power management too
    while true; do
        echo "Trying..."
        xscreensaver-command -exit
        # https://bbs.archlinux.org/viewtopic.php?id=134289
        xset -dpms
        xset dpms 0 0 0
        cpu-throttle-up
        sleep 60
    done
}

grep-functions () {
    declare -F | grep "$1"
}

rsync-remove-source () {
    # TODO: better interace
    # TODO: still put right picket fence
    # if [[ ! -d "$1" ]]; then
    #     yell "Empty arguments!"
    #     return 1
    # fi
    if ssh "${1}" true; then
        msg "Incoming from ${1}"
        local BACKUPDIR="rsync-backups-${1}-$(date-time-stamp)"
        rsync --progress --archive --checksum --backup --backup-dir="$BACKUPDIR" --rsh='ssh' --remove-source-files ${1}:"$2"/ .
        # will cause error if there are backups
        rmdir --ignore-fail-on-non-empty "$BACKUPDIR"
    else
        warn "Hostname $1 not found!"
    fi
}

rsync-check-source () {
    # do this before running above with same arguments
    if ssh "${1}" true; then
        # TODO: make explicitly that contents of that directory come into current directory
        rsync --verbose --checksum --progress --archive  --rsh='ssh' ${1}:"$2"/ .
    else
        warn "Hostname $1 not found!"
    fi
}

vcs-incoming () {
    # https://stackoverflow.com/questions/1331385/how-can-i-see-incoming-commits-in-git
    git diff --stat master origin/master
    git diff master origin/master
}

trim-mp3-to-30min () {
    ffmpeg -i "$1" -codec copy -ss 00:00:30 -t 00:30:00 "$2"
}

normalize-volume () {
    # set system volume to nice levels on one run
    amixer set Master 50%
    amixer set Master unmute
    # youtube volume sometimes stupid, normalize it too
    youtube-normalize-volume
    local DATESTAMP=$(date-time-stamp)
    notify-send "Normalizing volume" "$DATESTAMP" -t 5000
}

youtube-normalize-volume () {
    # global function to normalize volume in youtube windows
    # TODO: if no window here
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --name youtube | while IFS= read -r line; do
        if xdotool search --class conkeror | grep "${line}" >/dev/null; then
            xdotool windowfocus --sync "${line}";
            xdotool windowactivate --sync "${line}"
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.05
            conkeror -f youtube-normalize-volume
        fi
    done
    # TODO: very arbitrary, perhaps wait for something to return
    sleep 0.05
    xdotool windowactivate --sync ${CURRENTWINDOW}
}

find-iname () {
    #
    find . -iname '*'"$1"'*'
}

xset-query () {
    xset q
}

grep-gz-files () {
    # only elisp for now
    find -name "*.el.gz" -print0 | xargs -0 zgrep "$1"
}

strip-leading-trailing-chars () {
    # strip leading and trail characters I do not want for many applications
    # TODO: keep adding more as I need them
    # TODO: make work with more things
    read string
    echo "$string" | sed 's/^[-]*//' | sed 's/[-]*$//'
}
