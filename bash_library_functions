#!/bin/bash
# bash_library_functions is a set of bash functions for non-specific
# functionality.
#
# Copyright (C) 2015 Andrew Kroshko, all rights reserved.
#
# Author: Andrew Kroshko
# Maintainer: Andrew Kroshko <akroshko.public+devel@gmail.com>
# Created: Fri Mar 27, 2015
# Version: 20150920
# URL: https://github.com/akroshko/bash-stdlib
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.

# WARNING: most of this code has not been rigorously tested or
# verified, use at own risk if working with important data or in
# production settings

# TODO: the arguments of each function are not specified, however it
# would be desirable to add this to the docstring at some point

function test-fail () {
    # this function is just a test to judge a scripts behaviour based
    # on return values
    # TODO: also need a test error
    if [[ false ]]
    then
        echo "false"
        return 1
    fi
    echo "not false"
    return 0
}

function check-host () {
    # check if current host is a particular host, this will probably
    # become more complex as time goes on
    [[ $(hostname) == "$1" ]]
}

function need_new_directory () {
    # create a new directory if it does not already exist
    if [[ ! -d "$1" ]]
    then
        mkdir -p "$1"
    fi
}

function verify-operation () {
    # this function verifies a deletion and asks twice to make sure,
    # generally used to ensure an operation is successful before
    # deleting
    askmessage="$1"
    suremessage="$2"
    rmarg="$3"
    while true; do
        read -p "$askmessage" yn
        case $yn in
            # TODO: make a bit more general so I can select a command
            [Yy]* ) (home-trash "$rmarg"); break;;
            # are you sure you don't want to delete original
            [Nn]* )
                read -p "$suremessage" ynt
                case $ynt in
                    [Yy]* ) return 0;;
                    [Nn]* ) true;;
                    * ) echo "Try again!"
                esac
                ;;
            * ) echo "Please answer yes or no.";;
        esac
    done
}

function home-trash () {
    # delete by moving to a trash file that can be periodically
    # checked
    trashfile="$1"
    if [[ ! -d ~/tmp ]]
    then
        mkdir ~/tmp
    fi
    if [[ ! -d ~/tmp/trash ]]
    then
        mkdir ~/tmp/trash
    fi
    \mv --backup=t -- "$1" ~/tmp/trash
}

function date-time-stamp () {
    # return a time-stamp with date in standard format
    echo $(date +%Y%m%d%H%M%S)
}

function date-stamp () {
    echo $(date +%Y%m%d)
}

# move this to function ASAP
function memory-log () {
    while true; do { cat /proc/meminfo | sed -n 2p ; date ; } | tr "\n" " " ; echo ""; sleep 30; done >> ~/memory-$(date +%Y%m%d%H%M%S).log
}

function ag-show () {
    # show details of a debian package
    # TODO: make this work with bash_completion
    apt-cache show "$1"
}

function ag-search () {
    # search for a debian package
    # TODO: make this work with bash_completion
    apt-cache search "$1"
}

function ag-install () {
    # install a debian package
    # TODO: make this work with bash_completion
    sudo apt-get install "$1"

}

function ag-list () {
    # list files installed by a debian package
    # TODO: make this work with bash_completion
    dpkg-query -L "$1"
}

function ag-list-installed () {
    dpkg-query -l
}

function scp-lan () {
    # use scp over a LAN, sets some good options
    # XXXX: largely obsolete because best options over LAN or WAN
    # found to be similar
    scp -o "Compression yes" -c arcfour256 "$@"
}

function ssh-lan () {
    # use ssh over a LAN, sets some good options
    # XXXX: largely obsolete because best options over LAN or WAN
    # found to be similar
    ssh -o "Compression yes" -c arcfour256 "$@"
}

function sshx () {
    # use ssh -X over a LAN, sets some good options
    # XXXX: largely obsolete because best options over LAN or WAN
    # found to be similar
    ssh -X -o "Compression yes" -c arcfour256 "$@"
}

function sshnox () {
    # use ssh and explicitly disable X forwarding
    # XXXX: largely obsolete because best options over LAN or WAN
    # found to be similar
    ssh -o "ForwardX11 no" "$@"
}

function sshx-lan () {
    # finding compression outweighs cheap NAS for now
    ssh -X -o "Compression yes" -c arcfour256 "$@"
}

# TODO make these ssh-auto functions!
# TODO need rsync autossh lan tunnel
function autossh-tunnel () {
    # set up a tunnel using autossh
    # TODO: specify how this is used
    # XXXX: largely obsolete because best options over LAN or WAN
    # found to be similar
    autossh -M 0 -o "BatchMode yes" -o "Compression yes" -c blowfish-cbc -N "$@"
}

function autossh-tunnel-lan () {
    # set up a tunnel using autossh
    # TODO: specify how this is used
    # XXXX: largely obsolete because best options over LAN or WAN
    # found to be similar
    autossh -M 0 -o "BatchMode yes" -o "Compression yes" -c arcfour256 -N "$@"
}

function transform-resize-web () {
    # resize photos to a nice size for the web
    # TODO: change the output name?
    convert "$1" -resize 1200x800 "resize_$1"
}

# transform anything to mp3 using ffmpeg
function transform-ffmpeg-mp3 () {
    # convert any media file to an mp3
    # TODO: ffmpeg not on debian
    ffmpeg -i "$1" -f mp3 "${1%.*}.mp3"
}

function transform-rotate-right () {
    # rotate a photo right 90 degrees
    convert "$1" -rotate 90 "rotate_$1"
}

function transform-rotate-180 () {
    # flip a photo 180 degrees
    convert "$1" -rotate 180 "rotate_$1"
}

function transform-rotate-left () {
    # rotate a photo left 90 degrees
    convert "$1" -rotate 270 "rotate_$1"
}

function serve-here () {
    # serve the current directory here on port 8080
    ifconfig
    python -m SimpleHTTPServer 8080
}

function discover-network () {
    # use nmap to show network interfaces
    nmap --iflist
}

function discover-lan () {
    # scan current network, based on common home router addresses,
    # quickly using nmap
    # XXXX: generally takes less than a minute
    time nmap -sP 192.168.0-1.0-255
}

function discover-lan-super () {
    # scan current network, based on common home router addresses,
    # slowly using nmap
    # XXXX: generally takes less than a 10 minutes
    time sudo nmap -sS 192.168.0-1.0-255
}

function discover-lan-complete () {
    # scan current network completely using nmap
    time sudo nmap -sP 192.168.0.0/16
}

function discover-lan-complete-super () {
    # scan current network completely and slowly using nmap
    time sudo nmap -sS 192.168.0.0/16
}

function discover-connections () {
    # check current networking connections
    netstat -untap
}

function lpr-double-sided-portrait () {
    # print file as double-sided in portrait mode
    lpr -o sides=two-sided-long-edge "$1"
}

function lpr-double-sided-landscape () {
    # print file as double-sided in landscape mode
    lpr -o sides=two-sided-short-edge "$1"
}

function ls-sort-date () {
    # ls and sort by reverse date
    ls -ltr
}

function need_new_symlink () {
    # try to create a new symlink between files, if KILLSYMLINKS is
    # set to 1, then delete old symlinks
    # XXXX: does not delete files in same place as old symlinks
    if [[ $KILL_SYMLINKS == 1 ]]
    then
       if [[ ! -h "$2" ]]
       then
           echo "$2 is not a symlink and may not exist!!!"
       else
           # XXXX: should only delete if symlink because of conditional
           rm "$2"
       fi
    fi
    if [[ ! -h "$2" ]]
    then
        # symlink does not exist at all
        ln -s "$1" "$2"
    elif [[ -h "$2" && ! -e "$2" ]]
    then
        # symlink exists but is broken
        # XXXX: should only delete if symlink because of conditional
        rm -f "$2"
        ln -s "$1" "$2"
    fi
}

function match_string_array () {
    # check if a given string is in a given array
    # string in $1, array in $2
    local e
    for e in "${@:2}"; do [[ "$e" =~ "$1" ]] && return 0; done
    return 1
}

function not_match_string_array () {
    # check if a given string is not in a given array
    # string in $1, array in $2
    local e
    for e in "${@:2}"; do [[ "$e" =~ "$1" ]] && return 1; done
    return 0
}

function view-def () {
    # view the definition of a bash function
    declare -f "$1"
}

function read-file-regexp () {
    # read lines from a file and merge them into a regexp
    newregexp=""
    while read line
    do
        newregexp+=$line"|"
    done < "$1"
    echo ${newregexp::-1}
}

function clean-pwd-files-pretend () {
    # see if files in current directory can be renamed to be safe from
    # punctuation and unicode boogeymen
    rename -n "s|'||g" *
    rename -n "s|:||g" *
    rename -n "s|\xe2\x80\x99||g" *
    rename -n "s|\xe2\x80\x93|-|g" *
    rename -n "s|\xe2\x80\x94|-|g" *
    rename -n "s|\xc2\xa1|-|g" *
}

function clean-pwd-files () {
    # actually rename files in current directory to be safe from
    # punctuation and unicode boogeymen
    rename "s|'||g" *
    rename "s|:||g" *
    rename "s|\xe2\x80\x99||g" *
    rename "s|\xe2\x80\x93|-|g" *
    rename "s|\xe2\x80\x94|-|g" *
    rename "s|\xc2\xa1|i|g" *
}

function psg () {
    if [[ -z "$1" ]]
    then
        ps -efj | less
    else
        # TODO: this can be done better!
        ps -efj | head -n 1
        ps -efj | grep "$1"
    fi
}

function cpu-throttle-up () {
    sudo cpufreq-set -c 0 -g performance
    sudo cpufreq-set -c 1 -g performance
    sudo cpufreq-set -c 2 -g performance
    sudo cpufreq-set -c 3 -g performance
}

function cpu-throttle-down () {
    sudo cpufreq-set -c 0 -g powersave
    sudo cpufreq-set -c 1 -g powersave
    sudo cpufreq-set -c 2 -g powersave
    sudo cpufreq-set -c 3 -g powersave
}

function find-broken-symlinks () {
    # find- for useful find command variations
    find . -type l -xtype l
}

function xclip-show-all () {
    echo "========================================"
    echo "Primary"
    xclip -o -selection p
    echo "========================================"
    echo "Secondary"
    xclip -o -selection s
    echo "========================================"
    echo "Clipboard"
    xclip -o -selection c
}

function du-sort () {
    # sort by size after using du
    du --summarize --human-readable * | sort --human-numeric-sort
}

function dd-progress () {
    # TODO: spaces after |
    ps auxww | grep " dd " |grep -v grep |awk '{print $2}' |while read pid; do kill -USR1 $pid; done
}


function youtube-mp3 () {
    # download mp3 from youtube
    youtube-dl --extract-audio -audio-format mp3 "$1"
}

function dconf-grep () {
    # grep the GNOME config database
    dconf dump / | grep -i "$1"
}

function dconf-less () {
    # use less to view the GNOME config database
    dconf dump / | less
}

function fdi () {
    find . -iname "*${1}*"
}

function fgi () {
    if [[ -z "${2}" ]]
    then
        find . -type f -exec grep -H --color -n "${1}" {}  \;
    else
        find . -type f -iname "*${1}*" -exec grep -H --color -n "${2}" {}  \;
    fi
}

function harm-bash () {
    # TODO: check for function and is this appropriate
    killall xbindkeys
    source ${HOME}/.bash_profile
}

function harm-bashrc () {
    source ${HOME}/.bashrc
}

function backlight-percentage () {
    # TODO: very device dependent but useful to include, make more general
    echo "`cat /sys/class/backlight/intel_backlight/brightness`*100/`cat /sys/class/backlight/intel_backlight/max_brightness`" | bc -l | xargs printf "%1.0f\n"
}

function vcs-check-root () {
    # check if a pull is needed for for child directories if they correspond to common version control systems
    # from https://stackoverflow.com/questions/3258243/git-check-if-pull-needed
    # TODO: there are probably much nicer ways to do this
    for dirname in ./*
    do
        [[ -d "$dirname" ]] || continue
        # check for various things
        if [[ -d "$dirname/.git" ]]
        then
            # TODO: exclude lines saying [up to date] and just give a summary of branches
            echo "==== Checking     $dirname/.git ===========================================================================" | cut -c 1-80
            pushd . >> /dev/null
            cd "$dirname"
            git fetch --dry-run --verbose
            popd >> /dev/null
        elif [[ -d "$dirname/.hg" ]]
        then
            echo "==== Checking     $dirname/.hg ============================================================================" | cut -c 1-80
            # TODO: non-functional? I have no remaining hg repos
            # pushd . >> /dev/null
            # cd "$dirname"
            # hg fetch --dry-run --verbose
            # popd >> /dev/null
        elif [[ -d "$dirname/.svn" ]]
        then
            echo "==== Checking     $dirname/.svn ===========================================================================" | cut -c 1-80
            pushd . >> /dev/null
            cd "$dirname"
            svn status --show-updates
            popd >> /dev/null
        else
            echo "==== Not checking $dirname ================================================================================" | cut -c 1-80
        fi
    done
}

function fail2ban-check () {
    # check fail2ban status and show number of banned IPs for each date in the past
    sudo zcat /var/log/auth.log*.gz | grep 'Failed password' | grep sshd | awk '{print $1,$2}' | sort -k 1,1M -k 2n | uniq -c
    # a hack to find non-gz logs
    sudo cat /var/log/auth.lo*[^z] | grep 'Failed password' | grep sshd | awk '{print $1,$2}' | sort -k 1,1M -k 2n | uniq -c
    sudo fail2ban-client status ssh
    sudo fail2ban-client status ssh-root
}

function drop-caches () {
    su -c "free && sync && echo 3 > /proc/sys/vm/drop_caches && free"
}

function mount-disk-uuid () {
    # find mounted disk or ???
    UUID="$1"
    UUIDDEVICE="$(readlink -f /dev/disk/by-uuid/${UUID})"
    if grep -qs "$UUIDDEVICE" /etc/mtab
    then
        echo -e $(grep ^"${UUIDDEVICE}[[:space:]]\+" /etc/mtab | cut -d ' ' -f 2)
        return 0
    else
        # TODO: for now I have gnome mount for me
        echo "Disk not mounted!!!"
        return 1
        # # TODO: mount on a temporary directory
        # MOUNTPOINT=$(mktemp -d)
        # sudo mount "${IDDEVICE}" "${MOUNTPOINT}"
        # echo "${MOUNTPOINT}"
    fi
}

function vcs-diff-public () {
    # diff the "master" with the "public" branch for current directory or all child directories that are git repositories
    # XXXX: git only for now
    if [[ -d "./.git" ]]
    then
        git diff public..master
    else
        for dirname in ./*
        do
            if [[ -d "$dirname/.git" ]]
            then
                pushd . >> /dev/null
                cd "$dirname"
                if git rev-parse --verify public >> /dev/null 2>&1
                then
                    echo "==== Checking $dirname ================================================================================" | cut -c 1-80
                    git diff master..public --stat
                fi
                popd >> /dev/null
            fi
        done
    fi
}

function vcs-push-github () {
    # merge public branch and commit to github
    # XXXX: repository must be setup properly
    git checkout public
    if [[ $? != 0 ]]
    then
        echo "Checkout unsuccessful!"
        return 1
    fi
    git merge --squash -X theirs master
    COMMITCORRECT=n
    while [[ "$COMMITCORRECT" != "y" ]]
    do
        read -p "Enter commit message: " COMMITMESSAGE
        # TODO: add option for quit
        read -p "Use commit message (y/n/q)? " COMMITCORRECT
        if [[ "$COMMITCORRECT" == "q" ]]
        then
            echo "Aborting!"
            git checkout master
            return 1
        fi
    done
    git commit -a -m "$COMMITMESSAGE"
    # TODO: eventually go "public" locally to "master" globally
    git push --force --set-upstream github public
    git checkout master
}

function dpkg-purge-all () {
    # purge all files related to uninstalled packages
    # TODO: dangerous function, purges all old config files
    dpkg -l | grep ^rc | cut -d' ' -f3|xargs sudo dpkg -P
}

function pip-upgrade () {
    # upgrade all pip packages
    pip freeze --local | grep -v '^\-e' | cut -d = -f 1  | xargs -n1 pip install -U
}

function git-serve () {
    # a convienient command to browse code for now
    git instaweb
}

function envaddpath() {
    # based on answer from https://superuser.com/questions/39751/add-directory-to-path-if-its-not-already-there
    # having environment variable to modify comming first makes my scripts clear
    if [[ -d "$2" ]] && [[ ":${!1}:" != *":$2:"* ]]; then
        NEWVARIABLE="${!1}:$2"
        # strip leading and trailing :
        NEWVARIABLE=${NEWVARIABLE#:}
        NEWVARIABLE=${NEWVARIABLE%:}
        export $1="${NEWVARIABLE}"
    fi
}

################################################################################
## set interesting things for bashrc, should these be here or a seperate file?
################################################################################
# https://wiki.archlinux.org/index.php/Color_Bash_Prompt
# TODO: move this, should not force color prompt for using other bash functions
# XXXX: is it likely this may clobber other things in the namespace?
# Reset
Color_Off='\[\e[0m\]'       # Text Reset
# Regular Colors
Black='\[\e[0;30m\]'        # Black
Red='\[\e[0;31m\]'          # Red
Green='\[\e[0;32m\]'        # Green
Yellow='\[\e[0;33m\]'       # Yellow
Blue='\[\e[0;34m\]'         # Blue
Purple='\[\e[0;35m\]'       # Purple
Cyan='\[\e[0;36m\]'         # Cyan
White='\[\e[0;37m\]'        # White
# Bold
BBlack='\[\e[1;30m\]'       # Black
BRed='\[\e[1;31m\]'         # Red
BGreen='\[\e[1;32m\]'       # Green
BYellow='\[\e[1;33m\]'      # Yellow
BBlue='\[\e[1;34m\]'        # Blue
BPurple='\[\e[1;35m\]'      # Purple
BCyan='\[\e[1;36m\]'        # Cyan
BWhite='\[\e[1;37m\]'       # White
# Underline
UBlack='\[\e[4;30m\]'       # Black
URed='\[\e[4;31m\]'         # Red
UGreen='\[\e[4;32m\]'       # Green
UYellow='\[\e[4;33m\]'      # Yellow
UBlue='\[\e[4;34m\]'        # Blue
UPurple='\e[4;35m\]'        # Purple
UCyan='\[\e[4;36m\]'        # Cyan
UWhite='\[\e[4;37m\]'       # White
# Background
On_Black='\[\e[40m\]'       # Black
On_Red='\[\e[41m\]'         # Red
On_Green='\[\e[42m\]'       # Green
On_Yellow='\[\e[43m\]'      # Yellow
On_Blue='\[\e[44m\]'        # Blue
On_Purple='\[\e[45m\]'      # Purple
On_Cyan='\[\e[46m\]'        # Cyan
On_White='\[\e[47m\]'       # White
# High Intensity
IBlack='\[\e[0;90m\]'       # Black
IRed='\[\e[0;91m\]'         # Red
IGreen='\[\e[0;92m\]'       # Green
IYellow='\[\e[0;93m\]'      # Yellow
IBlue='\[\e[0;94m\]'        # Blue
IPurple='\[\e[0;95m\]'      # Purple
ICyan='\[\e[0;96m\]'        # Cyan
IWhite='\[\e[0;97m\]'       # White
# Bold High Intensity
BIBlack='\[\e[1;90m\]'      # Black
BIRed='\[\e[1;91m\]'        # Red
BIGreen='\[\e[1;92m\]'      # Green
BIYellow='\[\e[1;93m\]'     # Yellow
BIBlue='\[\e[1;94m\]'       # Blue
BIPurple='\[\e[1;95m\]'     # Purple
BICyan='\[\e[1;96m\]'       # Cyan
BIWhite='\[\e[1;97m\]'      # White
# High Intensity backgrounds
On_IBlack='\[\e[0;100m\]'   # Black
On_IRed='\[\e[0;101m\]'     # Red
On_IGreen='\[\e[0;102m\]'   # Green
On_IYellow='\[\e[0;103m\]'  # Yellow
On_IBlue='\[\e[0;104m\]'    # Blue
On_IPurple='\[\e[10;95m\]'  # Purple
On_ICyan='\[\e[0;106m\]'    # Cyan
On_IWhite='\[\e[0;107m\]'   # White
